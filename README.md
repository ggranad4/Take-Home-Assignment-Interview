### Rock Paper Scissors

My approach was at first to see if a player was sending the same shot over and over again. My frst thought was to create a checker on histories using .every( shot => shot === history[playerId][0]) but i thought this was kinda overboard on constantly checking the history list. Instead, I settled for finding the random which was less compute power and would create a more readable approach. Using a set since adding the same string would still result in the set size being 1. So once I find the randomPlayerId, I would then save this playerId and once I encountered the other playerId (which was the constant since there are only 3 players including custom) I would then use the histories variable to get that constant players first shot and save that.

This gave me an edge on random, since random will always shoot random and still potentially losing to constant. Custom once finding the radom will always beat constant meaning that every time it played constant it would be an automatic win.

(I attempted the bonus question, my appraoch was to follow round robin. Trying my best not to change the old initialization of the constructor i set the N variable be null if not passed. If passed i would create an N number of ports and if N was odd introduce a BYE to make players evenly play each other. BYE would allow the player to basiaclly wait a round before attempting to play another player. I was going to continue to follow the index of the player and use either % to basiclly wrap back around the amount of players to keep a consistent approach to all players playing each other evenly)
