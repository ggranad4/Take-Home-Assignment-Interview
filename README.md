### Rock Paper Scissors

My approach was at first to see if a player was sending the same shot over and over again. My frst thought was to create a checker on histories using .every( shot => shot === history[playerId][0]) but i thought this was kinda overboard on constantly checking the history list. Instead, I settled for finding the random which was less compute power and would create a more readable approach. Using a set since adding the same string would still result in the set size being 1. So once I find the randomPlayerId, I would then save this playerId and once I encountered the other playerId (which was the constant since there are only 3 players including custom) I would then use the histories variable to get that constant players first shot and save that.

This gave me an edge on random, since random will always shoot random and still potentially losing to constant. Custom once finding the radom will always beat constant meaning that every time it played constant it would be an automatic win.

(I attempted the bonus question, my appraoch was to follow round robin. Trying my best not to change the old initialization of the constructor i set the N variable be null if not passed. If passed i would create an N number of ports and if N was odd introduce a BYE to make players evenly play each other. BYE would allow the player to basiaclly wait a round before attempting to play another player. I was going to continue to follow the index of the player and use either % to basiclly wrap back around the amount of players to keep a consistent approach to all players playing each other evenly)

### Query an Ordered List

The main hint in this problem was first in the code we are handed the knownLength. On top of that reading the sentence ordered list gave me right away divide-conquer. Since we always started at 0 and no other checks, index++ I knew any approach would be better than this one.

My first idea was just seeing if checking the middle point would make a difference (middle index is the position above or below and change the starting point of tryNext) (did not). My other idea was to confirm that the time stamp was even in the list. (Not sure if this was necessary since it was 2000 always) but wanted to mimic a real approach to save some time and avoid any unnecessary calls. Lastly, dividing down the middle every call and attempting to get as close as possible to the index was the best approach. Reduced all the unnecessary calls. My main struggle with the problem was I kept returning result from data rather than the whole resolved data. Causing my console to constantly tell me false for all the positions it was looking for. Once i got the binary search down i would simply always either return the inded of the matched posiiton or an index close enough to actually confirm its inside the list. Using this approach and comparing it to the original dropped it significatly. But honeslty I wanted to try my best to make it even easier and readable so I basically created another approach. This approach was still on the brute forcey side but still better than starting from zero and ++ through the list. Instead I stepped through the list 250 times. Checked that index and if the posiiton was above this do another 250 steps until the positon was below that and starting there. binary search still blew this out the water but wanted to attempt to make something super super readable at first glace.

### Memory Leak Problem

I took a ton of time understanding what things meant. I had zero to no clue about what any of the code consisted of but i wanted to take the opportunity to put myself in an uncomfortable spot to see if my JS expereince can carry me in finding the issue in the code. But doing this was no help since i didnt understand at first what arrayBuffer was and all the other methods were attempting to do. I wrote a ton of comments on this section to basically not only save what i learned but also to jot down any notes or things that can help me better understand the code. Once i grasped what was going on. My mind first looked at the timeout thinking this was an easy solution and to clearTimeout since it was somehow still in the event loop somehow. But this was not the problem instead it was the sneaky reference of the original segment list. When we created var segment = segmentList[index] we were both pointing to the segment needed but also the reference so adding arrayBuffer to segment also updated the referece to segmentList. Creating arrayBuffer on that segment as well in the list. The tricky part was it was hard to catch when reading appendBuffer it looks like it safely removed the segment and removes it from memory. Almost like blocking the old reference from the list. I caught this by simply console logging what the segment list looked like after every iteration and I could see "arrayBuffer" being added to the segment inside of the original segmentList. Which was the cause of memory constantly growing. This is a classic reference problem in JavaScript. So I made a deep copy making sure that any changes made to this deep copy was not changing the old reference. Another approach I saw that worked and probably could go with my current soltion is after every iteration before segmentIndex++ we could segmentList[segmentIndex] = null and completely remove it from the old array as well but I was thinking that if in the future we want to use that segmentList again this would make it impossible.
